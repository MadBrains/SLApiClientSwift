// Extensions.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Alamofire

extension Bool: JSONEncodable {
    func encodeToJSON() -> Any { return self as Any }
}

extension Float: JSONEncodable {
    func encodeToJSON() -> Any { return self as Any }
}

extension Int: JSONEncodable {
    func encodeToJSON() -> Any { return self as Any }
}

extension Int32: JSONEncodable {
    func encodeToJSON() -> Any { return NSNumber(value: self as Int32) }
}

extension Int64: JSONEncodable {
    func encodeToJSON() -> Any { return NSNumber(value: self as Int64) }
}

extension Double: JSONEncodable {
    func encodeToJSON() -> Any { return self as Any }
}

extension String: JSONEncodable {
    func encodeToJSON() -> Any { return self as Any }
}

private func encodeIfPossible<T>(_ object: T) -> Any {
    if let encodableObject = object as? JSONEncodable {
        return encodableObject.encodeToJSON()
    } else {
        return object as Any
    }
}

extension Array: JSONEncodable {
    func encodeToJSON() -> Any {
        return self.map(encodeIfPossible)
    }
}

extension Dictionary: JSONEncodable {
    func encodeToJSON() -> Any {
        var dictionary = [AnyHashable: Any]()
        for (key, value) in self {
            dictionary[key] = encodeIfPossible(value)
        }
        return dictionary as Any
    }
}

extension Data: JSONEncodable {
    func encodeToJSON() -> Any {
        return self.base64EncodedString(options: Data.Base64EncodingOptions())
    }
}

private let dateFormatter: DateFormatter = {
    let fmt = DateFormatter()
    fmt.dateFormat = Configuration.dateFormat
    fmt.locale = Locale(identifier: "en_US_POSIX")
    return fmt
}()

extension Date: JSONEncodable {
    func encodeToJSON() -> Any {
        return dateFormatter.string(from: self) as Any
    }
}

extension UUID: JSONEncodable {
    func encodeToJSON() -> Any {
        return self.uuidString
    }
}

extension String: CodingKey {

    public var stringValue: String {
        return self
    }

    public init?(stringValue: String) {
        self.init(stringLiteral: stringValue)
    }

    public var intValue: Int? {
        return nil
    }

    public init?(intValue: Int) {
        return nil
    }

}

extension UnkeyedEncodingContainer {

    public mutating func encode<T>(_ value: T) throws {
        if let boolValue = value as? Bool { try encode(boolValue); return }
        if let doubleValue = value as? Double { try encode(doubleValue); return }
        if let floatValue = value as? Float { try encode(floatValue); return }
        if let intValue = value as? Int { try encode(intValue); return }
        if let int16Value = value as? Int16 { try encode(int16Value); return }
        if let int32Value = value as? Int32 { try encode(int32Value); return }
        if let int64Value = value as? Int64 { try encode(int64Value); return }
        if let int8Value = value as? Int8 { try encode(int8Value); return }
        if let uintValue = value as? UInt { try encode(uintValue); return }
        if let uint16Value = value as? UInt16 { try encode(uint16Value); return }
        if let uint32Value = value as? UInt32 { try encode(uint32Value); return }
        if let uint64Value = value as? UInt64 { try encode(uint64Value); return }
        if let uint8Value = value as? UInt8 { try encode(uint8Value); return }
        if let stringValue = value as? String { try encode(stringValue); return }
        if let arrayValue = value as? [Any] {
            var container = nestedUnkeyedContainer()
            for value in arrayValue {
                try container.encode(value)
            }
            return
        }
        if let mapValue = value as? [String: Any] {
            var container = nestedContainer(keyedBy: String.self)
            for (key, value) in mapValue {
                try container.encode(value, forKey: key)
            }
            return
        }
        throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: [], debugDescription: "Type is not encodable"))
    }
    
    public mutating func encodeIfPresent<T>(_ value: T?) throws {
        if let value = value {
            try encode(value)
        }
    }

}

extension KeyedEncodingContainerProtocol {

    public mutating func encode<T>(_ value: T, forKey key: Self.Key) throws {
        if let boolValue = value as? Bool { try encode(boolValue, forKey: key); return }
        if let doubleValue = value as? Double { try encode(doubleValue, forKey: key); return }
        if let floatValue = value as? Float { try encode(floatValue, forKey: key); return }
        if let intValue = value as? Int { try encode(intValue, forKey: key); return }
        if let int16Value = value as? Int16 { try encode(int16Value, forKey: key); return }
        if let int32Value = value as? Int32 { try encode(int32Value, forKey: key); return }
        if let int64Value = value as? Int64 { try encode(int64Value, forKey: key); return }
        if let int8Value = value as? Int8 { try encode(int8Value, forKey: key); return }
        if let uintValue = value as? UInt { try encode(uintValue, forKey: key); return }
        if let uint16Value = value as? UInt16 { try encode(uint16Value, forKey: key); return }
        if let uint32Value = value as? UInt32 { try encode(uint32Value, forKey: key); return }
        if let uint64Value = value as? UInt64 { try encode(uint64Value, forKey: key); return }
        if let uint8Value = value as? UInt8 { try encode(uint8Value, forKey: key); return }
        if let stringValue = value as? String { try encode(stringValue, forKey: key); return }
        if let arrayValue = value as? [Any] {
            var container = nestedUnkeyedContainer(forKey: key)
            for singleValue in arrayValue {
                try container.encode(singleValue)
            }
            return
        }
        if let mapValue = value as? [String: Any] {
            var container = nestedContainer(keyedBy: String.self, forKey: key)
            for (key, value) in mapValue {
                try container.encode(value, forKey: key)
            }
            return
        }
        throw EncodingError.invalidValue(value, EncodingError.Context(codingPath: [], debugDescription: "Type is not encodable"))
    }

    public mutating func encodeIfPresent<T>(_ value: T?, forKey key: Self.Key) throws {
        if let value = value {
            try encode(value, forKey: key)
        }
    }

    public mutating func encodeMap<T>(_ pairs: [Self.Key: T]) throws where T : Encodable {
        for (key, value) in pairs {
            try encode(value, forKey: key)
        }
    }

}

extension KeyedDecodingContainerProtocol {
    
    public func decode<T>(_ type: T.Type, forKey key: Self.Key) throws -> T {
        if let value = try? decode(Bool.self, forKey: key) { return value as! T }
        if let value = try? decode(Double.self, forKey: key) { return value as! T }
        if let value = try? decode(Float.self, forKey: key) { return value as! T }
        if let value = try? decode(Int.self, forKey: key) { return value as! T }
        if let value = try? decode(Int16.self, forKey: key) { return value as! T }
        if let value = try? decode(Int32.self, forKey: key) { return value as! T }
        if let value = try? decode(Int64.self, forKey: key) { return value as! T }
        if let value = try? decode(Int8.self, forKey: key) { return value as! T }
        if let value = try? decode(UInt.self, forKey: key) { return value as! T }
        if let value = try? decode(UInt16.self, forKey: key) { return value as! T }
        if let value = try? decode(UInt32.self, forKey: key) { return value as! T }
        if let value = try? decode(UInt64.self, forKey: key) { return value as! T }
        if let value = try? decode(UInt8.self, forKey: key) { return value as! T }
        if let value = try? decode(String.self, forKey: key) { return value as! T }
        if let value = try? decodeArray(Any.self, forKey: key) { return value as! T }
        if let value = try? decodeMap(Any.self, forKey: key) { return value as! T }
        throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: "Data is not decodable"))
    }
    
    public func decodeIfPresent<T>(_ type: T.Type, forKey key: Self.Key) throws -> T? {
        guard contains(key) else {
            return nil
        }
        if try decodeNil(forKey: key) {
            return nil
        }
        return try decode(type, forKey: key)
    }
    
    fileprivate func decodeArray<T>(_ type: T.Type, forKey key: Self.Key) throws -> [T] {
        var tmpArray = [T]()
        var nestedContainer = try nestedUnkeyedContainer(forKey: key)
        while !nestedContainer.isAtEnd {
            tmpArray.append(try nestedContainer.decode(T.self))
        }
        return tmpArray
    }
    
    fileprivate func decodeMap<T>(_ type: T.Type, forKey key: Self.Key) throws -> [String: T] {
        var map: [String : T] = [:]
        let container = try self.nestedContainer(keyedBy: Key.self, forKey: key)
        for key in container.allKeys {
            let value = try container.decodeIfPresent(T.self, forKey: key)
            map[key.stringValue] = value
        }
        return map
    }

    public func decodeMap<T>(_ type: T.Type, excludedKeys: Set<Self.Key>) throws -> [Self.Key: T] where T : Decodable {
        var map: [Self.Key : T] = [:]

        for key in allKeys {
            if !excludedKeys.contains(key) {
                let value = try decodeIfPresent(T.self, forKey: key)
                map[key] = value
            }
        }

        return map
    }

}

extension UnkeyedDecodingContainer {
    
    public mutating func decode<T>(_ type: T.Type) throws -> T {
        if let value = try? decode(Bool.self) { return value as! T }
        if let value = try? decode(Double.self) { return value as! T }
        if let value = try? decode(Float.self) { return value as! T }
        if let value = try? decode(Int.self) { return value as! T }
        if let value = try? decode(Int16.self) { return value as! T }
        if let value = try? decode(Int32.self) { return value as! T }
        if let value = try? decode(Int64.self) { return value as! T }
        if let value = try? decode(Int8.self) { return value as! T }
        if let value = try? decode(UInt.self) { return value as! T }
        if let value = try? decode(UInt16.self) { return value as! T }
        if let value = try? decode(UInt32.self) { return value as! T }
        if let value = try? decode(UInt64.self) { return value as! T }
        if let value = try? decode(UInt8.self) { return value as! T }
        if let value = try? decode(String.self) { return value as! T }
        if let value = try? decodeArray(Any.self) { return value as! T }
        if let value = try? decodeMap(Any.self) { return value as! T }
        throw DecodingError.dataCorrupted(DecodingError.Context(codingPath: [], debugDescription: "Data is not decodable"))
    }
    
    public mutating func decodeArray<T>(_ type: T.Type) throws -> [T] {
        var tmpArray = [T]()
        var nestedContainer = try nestedUnkeyedContainer()
        while !nestedContainer.isAtEnd {
            tmpArray.append(try nestedContainer.decode(T.self))
        }
        return tmpArray
    }
    
    public mutating func decodeMap<T>(_ type: T.Type) throws -> [String: T] {
        var map: [String : T] = [:]
        let container = try nestedContainer(keyedBy: String.self)
        for key in container.allKeys {
            let value = try container.decodeIfPresent(T.self, forKey: key)
            map[key.stringValue] = value
        }
        return map
    }
    
}











